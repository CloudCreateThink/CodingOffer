[toc]

### 一 Go

##### 1.限流算法有哪些

固定时间窗口；滑动时间窗口算法；漏桶和令牌桶算法；自适应限流；分布式限流

##### 2.负载均衡算法有哪些

轮询法；随机法；源地址哈希法；加权轮询法；加权随机法；最小连接数法

##### 3.熔断的三个状态和三种熔断降级策略

关闭 (Closed)；打开 (Open)；半打开 (Half-Open)。错误比例；错误计数；慢调用比例

##### 4.JWT的三部分组成

- 头部（Header）作用：记录令牌类型、签名算法等 
- 负载（Payload）作用：携带一些用户信息 
- 签名（Signature）作用：防止Token被篡改、确保安全性，Base64编码

##### 5.Slice底层切片对象的数据结构

1.指向底层数组的指针 2. 切片的长度  3. 切片的容量

##### 6.Map底层数据结构

1. hmap 哈希表：buckets是一个指针，指向一个bmap数组，存储多个桶。oldbuckets是一个指针，指向一个bmap数组，存储多个旧桶，用于扩容。overflow是一个指针，指向一个元素个数为2的数组，数组的类型是一个指针，指向一个slice，slice的元素是桶(bmap)的地址，这些桶都是溢出桶。

2. bmap 哈希桶：bmap是一个隶属于hmap的结构体，一个桶（bmap）可以存储8个键值对。

##### 7.Map扩容策略

1. 扩容条件：超过负载 map元素个数 > 6.5（负载因子） * 桶个数；溢出桶太多
2. 扩容机制：双倍扩容；等量扩容；渐进式扩容

 ##### 8. Channel操作

|          | 一个零值nil通道 | 一个非零值但已关闭的通道 | 一个非零值且尚未关闭的通道 |
| :------- | :-------------- | :----------------------- | :------------------------- |
| 关闭     | 产生恐慌        | 产生恐慌                 | 成功关闭                   |
| 发送数据 | 永久阻塞        | 产生恐慌                 | 阻塞或者成功发送           |
| 接收数据 | 永久阻塞        | 永不阻塞                 | 阻塞或者成功接收           |

##### 9.context包的方法

Deadline；Done；Err；Value

##### 10.GMP的含义

G：Goroutine；P：Process；M：machine

##### 11.GMP调度策略

队列轮转；系统调用；空闲睡眠

##### 12.GMP两种抢占式调度

协作式的抢占式调度；基于信号的抢占式调度

##### 13.GC的屏障有哪些

插入写屏障；删除写屏障；混合写屏障

##### 14.内存逃逸场景

指针逃逸；栈空间不足逃逸；动态类型逃逸；闭包引用对象逃逸

##### 15.go语言触发异常的场景

空指针解析；下标越界；除数为0；调用panic函数

##### 16.gin中间常用的四个方法

`c.Next()`、`c.Abort()`、`c.Set()`、`c.Get()`。

##### 17.go-micro的主要功能

服务发现；负载均衡；消息编码；请求/响应；Async Messaging；可插拔接口

##### 18.Jaeger组成

Jaeger Client；Agent；Collector；Data Store；Query

##### 19. promethues重要组件

- Prometheus Server:用于收集和存储时间序列数据。

- Client Library:客户端库成相应的metrics并暴露给Prometheus server

- Push Gateway:主要用于短期的jobs

- Exporters: 用于暴露已有的第三方服务的metrics给Prometheus

- Alertmanager: 从Prometheus server端接收到alerts后,会进行告警信息处理

### 二 MySQL 数据库

##### 1.索引有哪些

普通索引；唯一索引；主键索引；组合索引；全文索引；索引合并；覆盖索引；聚簇索引

##### 2.优化索引的方法

前缀索引优化；覆盖索引优化；主键索引最好是自增的；防止索引失效；

##### 3.索引失效的情况

函数，运算，否定操作符，连接条件，多个单列索引，最左前缀原则，范围查询，不会包含有NULL值的列，like 语句不要在列上使用函数和进行运算

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93.drawio.png)

##### 4.事务的四大特性

原子性、一致性、隔离性、持久性

##### 5.事务的隔离级别

未提交读、提交读、可重复读、串行化读

##### 6.MySQL的存储引擎有哪些

InnoDB、MyISAM、MEMORY、Archive

##### 7.MySQL有哪些锁

全局锁；表级锁：表锁、元数据锁、意向锁、AUTO-INC锁；行级锁：Record lock、Gap lock、Next-key lock、插入意向锁；悲观锁；乐观锁

##### 8.死锁的四个必要条件

互斥条件、请求与保持条件、不剥夺条件、循环等待条件

#### 9.MySQL的两个部分

服务层包括连接器、查询缓存、分析器、优化器、执行器等；存储引擎层负责数据的存储和提取

##### 10.MySQL日志有哪些

redo log 称为重做日志（持久性），undo log 称为回滚日志（原子性），binlog即binary log,二进制日志文件

##### 11.Innodb 通过哪三种链表来管理缓页

Free List （空闲页链表），管理空闲页；Flush List （脏页链表），管理脏页；LRU List，管理脏页+干净页，

##### 12.数据库中有哪些键

- **超键**：在关系中能唯一标识**元组的属性集**称为关系模式的超键
- **候选键**：不含有**多余属性的超键**称为候选键。也就是在候选键中，若再删除属性，就不是键了！
- **主键**：**用户选作元组标识的一个候选键程序主键**
- **外键**：如果关系模式**R中属性K是其它模式的主键**，那么**k在模式R中称为外键**。

主键为候选键的子集，候选键为超键的子集，而外键的确定是相对于主键的。

##### 13.MySQL优化的方法

为搜索字段创建索引；避免使用 Select *，列出需要查询的字段；垂直分割分表；选择正确的存储引擎

##### 14.SQL语句执行流程

1. 客户端请求->
2. 连接器（验证用户身份，给予权限） ->
3. 查询缓存（存在缓存则直接返回，不存在则执行后续操作）->
4. 分析器（对SQL进行词法分析和语法分析操作） ->
5. 优化器（主要对执行的sql优化选择最优的执行方案方法） ->
6. 执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）->
7. 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）

##### 15.数据库三范式是什么

1. 第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项；
2. 第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性；
3. 第三范式：任何非主属性不依赖于其它非主属性。

##### 16.主从复制中涉及到哪三个线程

1. binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。
2. I/O 线程 ：负责从主服务器上读取二进制日志，并写入从服务器的重放日志（Relay log）中。
3. SQL 线程 ：负责读取重放日志并重放其中的 SQL 语句。

##### 17.数据库结构优化的手段

范式优化、反范式优化、限定数据的范围、读/写分离、拆分表

### 三 计算机网络

##### 1.TCP/IP网络模型有哪几层

应用层、传输层、网络层、网络接口层

##### 2.HTTP缓存技术有哪些

强制缓存和协商缓存

##### 3.HTTP/2 相比 HTTP/1.1 性能上的改进

头部压缩、二进制格式、并发传输、 服务器主动推送资源

##### 4.HTTP/2 的缺陷

队头阻塞、TCP 和 TLS 握手时延、连接迁移需要重新连接

##### 5.QUIC 协议的特点

无队头阻塞、建立连接速度快、连接迁移

##### 6.TLS 协议是如何解决 HTTP 的风险的呢

信息加密、校验机制、身份证书

##### 7.SSL采用的加密算法

SSL采用混合加密算法，对称秘钥加密、非对称秘钥加密

##### 8.需要 TIME-WAIT 状态的两个原因

防止历史连接中的数据，被后面相同四元组的连接错误的接收；保证「被动关闭连接」的一方，能被正确的关闭；

##### 9.TCP头部中有哪些信息

序号、确认号、首部长、标志位、窗口、校验和

##### 10.TCP重传机制有哪些

超时重传、快速重传、SACK（选择性确认）、D-SACK（告诉发送方哪些数据被重复接收）

##### 11.TCP的防止包丢失技术手段

重传、滑动窗口、流量控制、拥塞控制

##### 12.TCP拥塞控制的四个算法（*）

1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复。

##### 13.TCP 协议如何保证可靠传输

确认和重传、数据校验、对失序数据包重排序、流量控制、拥塞控制、丢弃重复数据、应答机制

##### 14.TCP和UDP的区别

(1)TCP是可靠传输,UDP是不可靠传输;(2)TCP面向连接,UDP无连接;(3)TCP传输数据有序,UDP不保证数据的有序性;(4)TCP不保存数据边界,UDP保留数据边界;(5)TCP传输速度相对UDP较慢;(6)TCP有流量控制和拥塞控制,UDP没有;(７)TCP是重量级协议,UDP是轻量级协议;(８)TCP首部较长２０字节,UDP首部较短８字节;

##### 15.IPv6 的地址主要有以下类型地址

单播地址，用于一对一的通信；组播地址，用于一对多的通信；任播地址，用于通信最近的节点，最近的节点是由路由协议决定；没有广播地址

##### 16.IPv6 相比 IPv4 的首部改进

取消了首部校验和字段、取消了分片/重新组装相关字段、取消选项字段

##### 17.网络层常见协议

| 协议 | 名称                 | 作用                                                         |
| ---- | -------------------- | ------------------------------------------------------------ |
| IP   | 网际协议             | IP协议不但定义了数据传输时的基本单元和格式，还定义了数据报的递交方法和路由选择 |
| ICMP | Internet控制报文协议 | ICMP就是一个“错误侦测与回报机制”，其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性，是ping和traceroute的工作协议 |
| RIP  | 路由信息协议         | 使用“跳数”(即metric)来衡量到达目标地址的路由距离             |
| IGMP | Internet组管理协议   | 用于实现组播、广播等通信                                     |
| ARP  | 地址解析协议         | 根据IP地址获取物理地址                                       |
| RARP | 反向地址转换协议     | 根据物理地址获取IP地址                                       |
| PPP  | 点对点协议           | 主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案 |
| DHCP | DHCP                 | DHCP 动态获取 IP 地址                                        |
| NAT  | 网络地址转换 NAT     | 把私有 IP 地址转换成公有 IP 地址                             |

##### 18.应用层常见协议

| 协议   | 名称                       | 默认端口       | 底层协议                                                  |
| ------ | -------------------------- | -------------- | --------------------------------------------------------- |
| HTTP   | 超文本传输协议             | 80             | TCP                                                       |
| HTTPS  | 超文本传输安全协议         | 443            | TCP                                                       |
| Telnet | 远程登录服务的标准协议     | 23             | TCP                                                       |
| FTP    | 文件传输协议               | 20传输和21连接 | TCP                                                       |
| TFTP   | 简单文件传输协议           | 69             | UDP                                                       |
| SMTP   | 简单邮件传输协议（发送用） | 25             | TCP                                                       |
| POP    | 邮局协议（接收用）         | 110            | TCP                                                       |
| DNS    | 域名解析服务               | 53             | 服务器间进行域传输的时候用TCP 客户端查询DNS服务器时用 UDP |

##### 19.常见的HTTP状态码有哪些

| 状态码 | 类别                             | 含义                       |
| ------ | -------------------------------- | -------------------------- |
| 1XX    | Informational（信息性状态码）    | 接收的请求正在处理         |
| 2XX    | Success（成功状态码）            | 请求正常处理完毕           |
| 3XX    | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |
| 4XX    | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| 5XX    | Server Error（服务器错误状态码） | 服务器处理请求出           |

##### 20.OSI的七层模型和功能

- 物理层：底层数据传输，如网线；网卡标准。
- 数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址。
- 网络层：定义IP编址，定义路由功能；如不同设备的数据转发。
- 传输层：端到端传输数据的基本功能；如 TCP、UDP。
- 会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件。
- 表示层：数据格式标识，基本压缩加密功能。
- 应用层：各种应用软件，包括 Web 应用。

##### 21.常见的攻击

DDos攻击、Sql注入、SYN攻击、XSS攻击（跨站点脚本攻击）、CSRF攻击（跨站点请求伪造）

### 四 操作系统

##### 1.进程的状态有哪些

运行状态、就绪状态、阻塞状态、创建状态、结束状态、阻塞挂起状态、就绪挂起状态

##### 2.PCB进程控制块 具体包含什么信息

进程描述信息、进程控制和管理信息、资源分配清单、CPU 相关信息

##### 3.进程/线程间通信方式

管道、命名管道、消息队列、信号量、信号、共享内存、Socket通信

##### 4.进程类型有哪些

守护进程、僵尸进程和孤儿进程

##### 5.内存管理功能（*）

内存空间的分配与回收、地址转换、内存空间的扩充、存储保护

##### 6.常见的内存分配方式

从静态存储区域分配、在栈上创建、从堆上分配

##### 7.物理内存管理（*）

连续分配管理方式：内存碎片、分区的动态分配

非连续内存分配：分页、分段、段分页

##### 8.内存分配算法

首次适配、最优适配、最差适配

##### 9.调度算法有哪些

- 进程调度算法：（根据如何处理时钟中断分为：非抢占式调度算法、抢占式调度算法）（先来先服务调度算法、时间片轮转调度算法、短作业优先调度算法、最短剩余时间优先调度算法、高响应比优先调度算、优先级调度算法）

- 磁盘调度算法：先来先服务算法、最短寻道时间优先算法、扫描算法、循环扫描算法、LOOK 与 C-LOOK 算法

- 页面置换算法：先进先出置换算法（FIFO）、最佳置换算法（OPT）、最近最久未使用（LRU）算法、时钟（Clock）置换算法

##### 10.I/O多路复用的方式（*）

select、poll、epoll

##### 11.高性能网络模式（*）

Reactor：单 Reactor 单进程 / 线程、单 Reactor 多线程、多 Reactor 多进程 / 线程

Proactor：采用异步 I/O 实现的异步网络模型，感知的是已完成的读写事件

##### 12.死锁的条件

互斥条件、请求和保持条件、不剥夺条件、环路等待条件

##### 13.两大局部性原理是什么

时间局部性和空间局部性

##### 14.斥与同步问题

消费者生产者问题、哲学家进餐问题、读者写者问题

##### 15.malloc如何分配内存

brk是将进程数据段(.data)的最高地址指针向高处移动，这一步可以扩大进程在运行时的堆大小

mmap是在进程的虚拟地址空间中寻找一块空闲的虚拟内存，获得一块可以操作的堆内存。

##### 16.缓存的两个问题

预读失效和缓存污染

##### 17.原子操作的两种实现方式

缓存加锁或总线加锁

##### 18.服务器高并发解决方案

应用数据与静态资源分离、客户端缓存、集群和分布式、反向代理

##### 19.抖动和颠簸现象

刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数

### 五 Redis

##### 1.Redis常见的数据类型

String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）、BitMap）、HyperLogLog、GEO、Stream
##### 2.Redis的数据结构

简单动态字符串（SDS）、链表、字典、哈希表、跳跃表、压缩列表、quicklist、listpack、整数集合

##### 3.数据类型的底层数据结构

1. String 类型的底层的数据结构实现主要是 SDS（简单动态字符串）。

2. List 类型的底层数据结构是由**双向链表或压缩列表**实现的：

- 列表的元素个数小于 512 个，列表每个元素的值都小于 64 字节，Redis 会使用**压缩列表**作为 List 类型的底层数据结构；否则使用**双向链表**作为 List 类型的底层数据结构；

​	**在 Redis 3.2 版本之后，List 底层数据结构就由 quicklist 实现了，替代双向链表和压缩列表**。

3. Hash 类型的底层数据结构是由**压缩列表或哈希表**实现的：

- 如果哈希类型元素个数小于 512 个，所有值小于 64 字节的话，Redis 会使用**压缩列表**作为 Hash 类型的底层数据结构；否则使用**哈希表**作为 Hash 类型的底层数据结构。

​	**在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现**。

4. Set 类型的底层数据结构是由**哈希表或整数集合**实现的：

- 如果集合中的元素都是整数且元素个数小于 512 个，Redis 会使用**整数集合**作为 Set 类型的底层数据结构；否则使用**哈希表**作为 Set 类型的底层数据结构。

5. Zset 类型的底层数据结构是由**压缩列表或跳表**实现的：

- 如果有序集合的元素个数小于 128 个，并且元素的值小于 64 字节时，Redis 会使用**压缩列表**作为 Zset 类型的底层数据结构；否则使用**跳表**作为 Zset 类型的底层数据结构；

​	**在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。**

##### 4.Redis的过期删除策略

定时过期、惰性过期、定期清除；Redis中使用惰性过期和定期过期两种过期策略

##### 5.Redis的内存淘汰策略

1、不进行数据淘汰的策略：noeviction 表示当运行内存超过最大设置内存时，不淘汰任何数据，如果有新的数据写入，则会触发 OOM

2、进行数据淘汰的策略：

在设置了过期时间的数据中进行淘汰：

- **volatile-random**：随机淘汰设置了过期时间的任意键值；
- **volatile-ttl**：优先淘汰更早过期的键值。
- **volatile-lru**（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；
- **volatile-lfu**（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；

在所有数据范围内进行淘汰：

- **allkeys-random**：随机淘汰任意键值;
- **allkeys-lru**：淘汰整个键值中最久未使用的键值；
- **allkeys-lfu**（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。

##### 6.Redis如何实现持久化

AOF 日志：写回硬盘策略（Always、Everysec、No）、AOF 重写机制

RDB 快照：写时复制技术

混合持久化方式：前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据

##### 7.主从复制的三种模式

全量复制、基于长连接的命令传播、增量复制

##### 8.哨兵的功能

集群监控、消息通知、故障转移、配置中心

##### 9.哨兵主备切换的数据丢失的两种情况

异步复制导致的数据丢失、脑裂导致的数据丢失

##### 10.Redis 如何实现服务高可用

主从复制、哨兵模式、切片集群模式

##### 11.缓存的问题有哪些

缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存击穿、缓存降级

##### 12.如何保证缓存与数据库的双写一致性

Cache Aside Pattern：读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。更新的时候，**先删除缓存，然后再更新数据库**。

##### 13.常见的数据优化方案

缓存双淘汰法：先淘汰缓存、再写数据库、往消息总线esb发送一个淘汰消息，发送立即返回

异步淘汰缓存：新增一个线下的读取binlog异步淘汰缓存模块，读取binlog总的数据，再进行异步淘汰。

##### 14.分布式寻址算法有哪些

hash 算法（大量缓存重建）；一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）；Redis cluster 的 hash slot 算法

### 六 Python

##### 1.Django中间件

Django 在中间件中预置六个方法，这六个方法的区别在于不同的阶段执行，对输入或输出进行干预：

1.初始化：无需任何参数，服务器响应第一个请求的时候调用一次，用于确定是否启用当前中间件。

2.处理请求前：在每个请求上调用，返回 None 或 HttpResponse 对象。

3.处理视图前：在每个请求上调用，返回 None 或 HttpResponse 对象。

4.处理模板响应前：在每个请求上调用，返回实现了 render 方法的响应对象。

5.处理响应后：所有响应返回浏览器之前被调用，在每个请求上调用，返回 HttpResponse 对象。

6.异常处理：当视图抛出异常时调用，在每个请求上调用，返回一个 HttpResponse 对象。

##### 2.爬虫框架或者模块有哪些

urllib、urllib2、requests、Scrapy、selenium

##### 3.常见的反爬虫方法

(1) 通过 Headers 反爬虫(2) 基于用户行为反爬虫(3) 动态页面的反爬虫

##### 4.常见的机器学习算法有哪些

KNN算法、线性回归法、决策树算法、随机森林算法

##### 5.内存管理机制：

引用计数、垃圾回收（引用计数、标记清除、分代回收）、内存池。

##### 七 前端

##### 1.Vue 生命周期的理解

总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。

**创建前后：**在beforeCreated阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el还没有。

**载入前后：**在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。

**更新前后：**当data变化时，会触发beforeUpdate和updated方法。

**销毁前后：**在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在

##### 2.Vue的优点

轻量级框架；简单易学；双向数据绑定；组件化；视图，数据，结构分离；虚拟DOM；运行速度更快

### 八 项目

##### 1.基于机器学习的冬奥会智能分析与预测系统

**介绍一下项目：**

本项目是我校的省级创新创业项目，我负责后端开发与数据库设计，项目主要包括两部分，第一为冬奥会的数据分析与图表展示，第二为使用随机森林算法根据往届冬奥会信息进行预测模型训练，预测各个国家在下一届冬奥会所获得的奖牌情况。采用前后端分离开发，前端采用Vue+Echarts，后端采用GoLang的gin框架进行开发，预测算法机器学习中的随机森林算法，数据库采用Mysql和Redis，数据来源为2022北京冬奥组委官网、国际奥林匹克官网等网站收集奖牌及视频数据，百度百科收集运动员个人信息数据，聚会数据网收集预测因素数据。

**项目重点难点有什么：**

预测使用的方法为随机森林。

预测模型建立时考虑了9种可能对预测产生影响的因素,分别为(1).参加冬奥会男子数(2).参加冬奥会女子数(3).是否为主办方(4).国家人均gdp(5).国家总gdp(6).国家人口总数 (7).国家社会制度 (8).获得奖牌排行 (9).获得奖牌占总奖牌数的比率。

首先用RandomForestRegressor按照不同的权重对9种因素进行模型训练,然后使用同种方法对每一种因素进行训练,并预测出2026年的值,再将2026年的数据带入总的预测模型,并得出2026年冬奥会各个国家获得的奖牌,并将2022年的奖牌进行数据检验,最后将获得的数据进行保存。

**工作内容：**

1. 从冬奥会多个官网收集数据，进行处理，存储到MySQL数据库，进行数据库表结构设计。

2. 首页数据缓存到Redis数据库，增加系统可维护性，提高网页的响应速度，提高并发访问量。

3. 使用随机森林算法建立预测奖牌模型，进行各个国家奖牌预测，并将结果数据缓存到Redis中。

4. 使用Viper配置项目参数，增加项目可扩展性，使用Swagger编写注释，方便前端理解接口和代码调试。

5. 项目使用JWT跨域认证，增加用户数据安全性，注册使用Email进行身份验证，保障了账号的真实性。

6. 使用Zap日志进行日志收集，提高日志收集效率，能够收集程序运行多种基本信息，便于系统调试。

**项目使用了哪些技术**

本项目采用前后端分离开发，前端采用Vue+Echarts，后端采用GoLang的gin框架进行开发，预测算法机器学习中的随机森林算法，使用的语言为Python，在开发过程中我们使用了一下技术：

1. 使用zap日志库进行系统日志收集
2. 使用配置信息viper进行系统参数配置
3. 使用swagger编写接口规范和接口文档
4. 使用JWT跨域认证，实现Token机制
5. 使用雪花算法生成用户ID，在并发操作下，保证了数据的唯一性，用户不知道系统内部信息
6. 使用go-redis，首页数据缓存到Redis数据库，邮箱验证码和Token保存在Redis中
7. 使用gorm开发，进行MySQL数据库操作。

**从项目中学到了什么**

1. 对项目开发的规范流程有了具体的掌握
2. 使用多种中间件完成项目开发，加快项目开发效率，使项目更加健壮
3. 使用机器算法完成预测功能，对机器学习有了更加深入的理解

##### 2.基于微服务的通用账户功能系统

**介绍一下项目：**

项目是基于Micro框架开发的通用的账户功能系统，采用Mysql+Redis+Docker进行项目开发，包括账户的基本操作如账号增删改查和权限操作，使用配置中心、链路追踪、监控等相关技术，使用ProtoBuf进行数据传输和Api接口定义，相关插件使用Docker进行安装，避免花费大量精力放在安装部署方面。

**工作内容：**

1. 使用ProtoBuf进行参数传输和定义相关接口，定义了13个相关的账户功能接口。

2. 使用Redis缓存Email验证码和存储Token，提高用户注册效率，实现定时清除Token机制。

3. 使用Docker部署多个微服务插件，如Consul，Jaeger，Prometheus等，降低开发难度，提高开发效率。

4. 客户端使用负载均衡，大大提高项目的并发量，使用Prometheus进行项目监控，及时发现并解决问题。

**项目重点难点有什么**

1. 对ProtoBuf需要定义的参数和接口进行细致的思考
2. 使用Docker、Docker Compose进行插件安装和快速启动
3. 对多个微服务插件的使用和配置

**项目使用了哪些技术**

1. 使用go语言进行项目开发
2. 使用go-micro微服务框架进行服务端开发
3. 使用Docker安装部署中间件，加快开发效率
4. 使用ProtoBuf行数据传输和Api接口定义
5. 使用Gorm与Mysql数据库进行交互
6. 使用Zap日志库进行日志记录

**从项目中学到了什么**

1. 学到了微服务开发流程

2. Docker、Docker Compose的基本使用

3. Proto的使用、命令、编写

4. 对微服务组件有了更加深入的了解

5. 对微服务的作用、使用和开发有了更加深入的了解

6. 对中间件整合到项目中更加熟悉
