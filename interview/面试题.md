[toc]

1.排序算法    2. ACM输入输出    3.TCP三次握手四次挥手     4.TCP拥塞控制    5.Docker    6.k8s           7.Go Context   8.JWT   9.go垃圾回收   10.进程线程协程   11.三门定理   12.for range   13.微服务鉴权14.GMP   15.goroutine   16.网页加载过程   17.RPC   18.chan   19.mysql索引（包括创建） 20.mysql存储引擎    21.I/O多路复用    22.线程池    23. redis数据结构    24.mysql分库分表     25.正向反向代理26.Kafka      27.链表反转   链表倒数第K个数    28.最长回文子序列 最长公共子序列 最长回文子串    29. 两数之和 三数之和 四数之和 回文子串

#### 1. 排序算法

1. 冒泡排序

   冒泡排序是一种基本的排序算法，它的原理是将相邻的元素两两比较，将小数放在前面，大数放在后面。这样一趟下来，最大的数就被排在了最后面。重复以上的步骤，直到全部元素排序完成。

   时间复杂度：最坏情况下为O(n^2)，最好情况下为O(n)。平均时间复杂度为O(n^2)。

   ```
   func bubbleSort(arr []int) {
       n := len(arr)
       for i := 0; i < n-1; i++ {
           for j := 0; j < n-i-1; j++ {
               if arr[j] > arr[j+1] {
                   arr[j], arr[j+1] = arr[j+1], arr[j]
               }
           }
       }
   }
   ```

2. 选择排序

   选择排序是一种简单直观的排序算法，其基本思想是：首先在未排序的数列中找到最小元素，然后将其存放到数列的起始位置；接着再从剩余未排序的元素中继续寻找最小的元素，然后放到已排序序列的末尾。重复以上步骤，直到排序完成。

   时间复杂度：最坏情况下为O(n^2)，最好情况下为O(n^2)。平均时间复杂度为O(n^2)。

   ``` 
   func selectionSort(arr []int) {
       n := len(arr)
       for i := 0; i < n-1; i++ {
           minIndex := i
           for j := i + 1; j < n; j++ {
               if arr[j] < arr[minIndex] {
                   minIndex = j
               }
           }
           arr[i], arr[minIndex] = arr[minIndex], arr[i]
       }
   }
   ```

3. 插入排序

   插入排序是一种简单直观的排序算法，其基本思想是：将未排序的数插入到已排序数列中的适当位置，直到所有元素都被插入到已排序序列中。

   时间复杂度：最坏情况下为O(n^2)，最好情况下为O(n)。平均时间复杂度为O(n^2)。

   ```
   func insertionSort(arr []int) {
       n := len(arr)
       for i := 1; i < n; i++ {
           temp := arr[i]
           j := i - 1
           for ; j >= 0 && arr[j] > temp; j-- {
               arr[j+1] = arr[j]
           }
           arr[j+1] = temp
       }
   }
   ```

4. 希尔排序

   原理：希尔排序是一种基于插入排序的排序算法，先将待排序的数组按照一定的间隔（增量）分成若干子序列，对每个子序列进行插入排序，随着增量逐渐减少，每个子序列包含的元素越来越多，当增量减至1时，整个序列合并成了一次排序。

   时间复杂度：希尔排序的时间复杂度与增量序列的选择有关，目前最好的时间复杂度为O(nlog^2 n)，最坏情况下的时间复杂度为O(n^2)。 空间复杂度：希尔排序的空间复杂度为O(1).

   ```
   func shellSort(arr []int) {
       n := len(arr)
       for gap := n / 2; gap > 0; gap /= 2 {
           for i := gap; i < n; i++ {
               for j := i; j >= gap && arr[j-gap] > arr[j]; j -= gap {
                   arr[j], arr[j-gap] = arr[j-gap], arr[j]
               }
           }
       }
   }
   ```

5. 归并排序

   原理：将一个无序的数组递归地分成两个小的有序数组，最后将这些小的有序数组归并为一个有序数组。具体来说，将原数组不断二分，直到每个小数组只有一个元素。然后再将这些小数组依次归并为一个大的有序数组。

   时间复杂度：O(nlogn)

   ```
   func mergeSort(arr []int) []int {
       if len(arr) <= 1 {
           return arr
       }
       mid := len(arr) / 2
       left := mergeSort(arr[:mid])
       right := mergeSort(arr[mid:])
       return merge(left, right)
   }
   func merge(left, right []int) []int {
       result := make([]int, len(left)+len(right))
       i, j, k := 0, 0, 0
       for i < len(left) && j < len(right) {
           if left[i] < right[j] {
               result[k] = left[i]
               i++
           } else {
               result[k] = right[j]
               j++
           }
           k++
       }
       for i < len(left) {
           result[k] = left[i]
           i++
           k++
       }
       for j < len(right) {
           result[k] = right[j]
           j++
           k++
       }
       return result
   }
   ```

6. 快速排序

   原理：选择一个基准元素，将数组分成两个部分，小于基准元素的放在左边，大于基准元素的放在右边。然后对左右两个部分递归地进行快速排序。

   时间复杂度：O(nlogn) 空间复杂度：O(logn)

   ```
   func quickSort(arr []int, left int, right int) {
   	if left < right {
   		pivotIndex := partition(arr, left, right)
   		quickSort(arr, left, pivotIndex-1)
   		quickSort(arr, pivotIndex+1, right)
   	}
   }
   func partition(arr []int, left int, right int) int {
   	pivot := arr[left]
   	for left < right {
   		for left < right && arr[right] >= pivot {
   			right--
   		}
   		arr[left] = arr[right]
   		for left < right && arr[left] <= pivot {
   			left++
   		}
   		arr[right] = arr[left]
   	}
   	arr[left] = pivot
   	return left
   }
   ```

7. 计数排序

   原理：计数排序是一种非比较排序算法，通过统计待排序元素中小于等于每个元素的个数来确定每个元素的位置，从而达到排序的目的。

   时间复杂度：计数排序的时间复杂度为O(n+k)，其中k为待排序元素中的最大值。

   空间复杂度：计数排序的空间复杂度为O(n+k)。

   ```
   func countingSort(arr []int) {
       n := len(arr)
       if n == 0 {
           return
       }
       max := arr[0]
       for _, v := range arr {
           if v > max {
               max = v
           }
       }
       count := make([]int, max+1)
       for _, v := range arr {
           count[v]++
       }
       for i := 1; i <= max; i++ {
           count[i] += count[i-1]
       }
       res := make([]int, n)
       for i := n - 1; i >= 0; i-- {
           res[count[arr[i]]-1] = arr[i]
           count[arr[i]]--
       }
       for i := 0; i < n; i++ {
           arr[i] = res[i]
       }
   }
   ```

8. 堆排序

   堆排序是一种选择排序，其时间复杂度为O(nlogn)。其原理是将待排序的序列构造成一个大顶堆或小顶堆，从而得到排序结果。大顶堆和小顶堆的区别在于父节点和子节点的大小关系。

   时间复杂度：O(nlogn) 空间复杂度：O(1)

   ```
   func heapSort(nums []int) []int {
       n := len(nums)
       for i := n/2 - 1; i >= 0; i-- {
           heapify(nums, n, i)
       }
       for i := n - 1; i > 0; i-- {
           nums[0], nums[i] = nums[i], nums[0]
           heapify(nums, i, 0)
       }
       return nums
   }
   func heapify(nums []int, n int, i int) {
       largest := i
       left := 2*i + 1
       right := 2*i + 2
   
       if left < n && nums[left] > nums[largest] {
           largest = left
       }
       if right < n && nums[right] > nums[largest] {
           largest = right
       }
       if largest != i {
           nums[i], nums[largest] = nums[largest], nums[i]
           heapify(nums, n, largest)
       }
   }
   ```

9. 桶排序

   桶排序是一种线性排序，它的基本思想是将数据分到有限数量的桶里，然后对每个桶进行排序，最后将各个桶中的数据按照顺序依次排列组成有序序列。桶排序假设数据服从均匀分布，将数据分到桶中时桶内数据越接近越好。

   时间复杂度：O(n)  空间复杂度：O(n)

   ```
   func bucketSort(nums []int) []int {
       n := len(nums)
       maxVal := max(nums)
       bucketSize := maxVal/10 + 1
       buckets := make([][]int, bucketSize)
       for i := 0; i < n; i++ {
           index := nums[i] / 10
           buckets[index] = append(buckets[index], nums[i])
       }
       res := make([]int, 0, n)
       for _, bucket := range buckets {
           if len(bucket) > 0 {
               sort.Ints(bucket)
               res = append(res, bucket...)
           }
       }
       return res
   }
   func max(nums []int) int {
       maxVal := nums[0]
       for _, num := range nums {
           if num > maxVal {
               maxVal = num
           }
       }
       return maxVal
   }
   ```

10. 基数排序

    基数排序的原理是将待排序的数字分成个位、十位、百位等各个位上的数字，然后按照每一位上的数字进行排序。具体实现过程中，可以使用计数排序对每一位进行排序，从最低位到最高位依次进行排序，最终得到排好序的数组。其中k是数字位数。

    时间复杂度：O(nk) 空间复杂度：O(n+k)

    ```
    func RadixSort(arr []int) []int {
        length := len(arr)
        if length <= 1 {
            return arr
        }
        // 找到最大值
        maxVal := arr[0]
        for _, val := range arr {
            if val > maxVal {
                maxVal = val
            }
        }
        // 从个位开始，对数组arr按"指数"进行排序
        for exp := 1; maxVal/exp > 0; exp *= 10 {
            arr = countingSort(arr, exp)
        }
        return arr
    }
    func countingSort(arr []int, exp int) []int {
        length := len(arr)
        // 统计数组中每个元素出现的次数
        count := make([]int, 10)
        for i := 0; i < length; i++ {
            count[(arr[i]/exp)%10]++
        }
        // 计算每个元素的位置
        for i := 1; i < 10; i++ {
            count[i] += count[i-1]
        }
        // 从后往前遍历元素，将它放到有序数组中的对应位置
        result := make([]int, length)
        for i := length - 1; i >= 0; i-- {
            index := (arr[i]/exp)%10
            result[count[index]-1] = arr[i]
            count[index]--
        }
        return result
    }
    ```

#### 2. ACM输入输出

```
func main() {
	x := []rune("str") // 字符串转rune切片
	fmt.Println(x)
	
	var m, n int
	fmt.Scan(&m, &n)
	fmt.Println(m, n)

	for {
		_, err := fmt.Scan(&m, &n)
		if err == io.EOF {
			break
		}
		fmt.Println(m, n)
	}

	inputReader := bufio.NewReader(os.Stdin) // 返回一个读取器实例Reader
	input, _ := inputReader.ReadString('\n') // 按照分隔符读取内容
	strs := strings.Fields(input)            // 按照空格分割字符串,返回字符串切片
	fmt.Println(strs[0])

	for {
		inputReader := bufio.NewReader(os.Stdin)   // 返回一个读取器实例Reader
		input, err := inputReader.ReadString('\n') // 按照分隔符读取内容
		strs := strings.Fields(input)              // 按照空格分割字符串,返回字符串切片
		fmt.Println(strs[0])

		if err == io.EOF {
			break
		}
	}

	scanner := bufio.NewScanner(os.Stdin)
	for scanner.Scan() {
		s := scanner.Text()
		s_arr := strings.Split(s, " ")
		fmt.Println(s_arr)
	}

	sort.Ints([]int{}) // 对int类型的切片升序排序
	sort.Float64s([]float64{})
	sort.Strings([]string{})
	sort.Sort(sort.Reverse(sort.IntSlice([]int{})))

	family := []struct {
		Name string
		Age  int
	}{
		{"Alice", 23},
		{"David", 2},
	}
	sort.Slice(family, func(i, j int) bool { //SliceStable
		return family[i].Age < family[j].Age
	})

	//math.MaxInt
	//math.MinInt
	//Abs(x float64) float64	传入 x 参数，返回 x 的绝对值
	//Max(x, y float64) float64	传入 x、y 参数，返回 x 与 y 中的最大值
	//Min(x, y float64) float64	传入 x、y 参数，返回 x 和 y 中的最小值
	//Ceil(x float64) float64	传入 x 参数，返回一个大于等于 x 的最小整数值，也就是向上取整
	//Ceil(x float64) float64	传入 x 参数，返回一个小于等于 x 的最小整数值，也就是向下取整
	//Trunc(x float64) float64	传入 x 参数，返回浮点数 x 的整数部分
	//Dim(x, y float64) float64	传入 x、y 参数，返回 x-y 与 0 中最大的值
	//Mod(x, y float64) float64	对 x / y 进行取余运算 x % y
	//Pow(x, y float64) float64	计算 x 的 y 次幂
	//Sqrt(x float64) float64	对 x 开平方
	//Cbrt(x float64) float64	对 x 开立方
	//Modf(f float64) (int float64, frac float64)	分别取出 f 的整数部分和小数部分
}
```



#### 3.TCP三次握手四次挥手

**三次握手过程**

- **初始状态**：客户端处于 `closed(关闭)`状态，服务器处于 `listen(监听)` 状态。
- **第一次握手**：客户端发送请求报文将 `SYN = 1`同步序列号和初始化序列号`seq = x`发送给服务端，发送完之后客户端处于`SYN_Send`状态。（验证了客户端的发送能力和服务端的接收能力）
- **第二次握手**：服务端受到 `SYN` 请求报文之后，如果同意连接，会以自己的同步序列号`SYN(服务端) = 1`、初始化序列号 `seq = y`和确认序列号（期望下次收到的数据包）`ack = x+ 1` 以及确认号`ACK = 1`报文作为应答，服务器为`SYN_Receive`状态。（问题来了，两次握手之后，站在客户端角度上思考：我发送和接收都ok，服务端的发送和接收也都ok。但是站在服务端的角度思考：哎呀，我服务端接收ok，但是我不清楚我的发送ok不ok呀，而且我还不知道你接受能力如何呢？所以老哥，你需要给我三次握手来传个话告诉我一声。你要是不告诉我，万一我认为你跑了，然后我可能出于安全性的考虑继续给你发一次，看看你回不回我。）
- **第三次握手**： 客户端接收到服务端的 `SYN + ACK`之后，知道可以下次可以发送了下一序列的数据包了，然后发送同步序列号 `ack = y + 1`和数据包的序列号 `seq = x + 1`以及确认号`ACK = 1`确认包作为应答，客户端转为`established`状态。（分别站在双方的角度上思考，各自ok）

**四次挥手过程**

- **初始化状态**：客户端和服务端都在连接状态，接下来开始进行四次分手断开连接操作。
- **第一次分手**：第一次分手无论是客户端还是服务端都可以发起，因为 TCP 是全双工的。

- **第二次分手**：服务端接收到客户端的释放请求连接之后，**知道客户端没有数据要发给自己了**，**然后服务端发送ACK = 1告诉客户端收到你发给我的信息**，此时服务端处于 CLOSE_WAIT 等待关闭状态。（服务端先回应给客户端一声，我知道了，但服务端的发送数据能力即将等待关闭，于是接下来第三次就来了。）
- **第三次分手**：此时服务端向客户端把所有的数据发送完了，然后发送一个FIN = 1，**用于告诉客户端，服务端的所有数据发送完毕**，**客户端你也可以关闭接收数据连接了**。此时服务端状态处于LAST_ACK状态，来等待确认客户端是否收到了自己的请求。（服务端等客户端回复是否收到呢，不收到的话，服务端不知道客户端是不是挂掉了还是咋回事呢，所以服务端不敢关闭自己的接收能力，于是第四次就来了。）
- **第四次分手**：此时如果客户端收到了服务端发送完的信息之后，就发送ACK = 1，告诉服务端，客户端已经收到了你的信息。**有一个 2 MSL 的延迟等待**。

#### 4.TCP拥塞控制

拥塞控制目的是防止数据过多注入到网络中导致网络资源（路由器、交换机等）过载。因为拥塞控制涉及网络链路全局，所以属于全局控制。控制拥塞使用拥塞窗口。

拥塞控制主要是四个算法：1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复。

**慢热启动算法 – Slow Start**

所谓慢启动，也就是TCP连接刚建立，一点一点地提速，试探一下网络的承受能力，以免直接扰乱了网络通道的秩序。

慢启动算法：

1. 连接建好的开始先初始化拥塞窗口cwnd大小为1，表明可以传一个MSS大小的数据。
2. 每当收到一个ACK，cwnd大小加一，呈线性上升。
3. 每当过了一个往返延迟时间RTT(Round-Trip Time)，cwnd大小直接翻倍，乘以2，呈指数让升。
4. 还有一个ssthresh（slow start threshold），是一个上限，当cwnd >= ssthresh时，就会进入“拥塞避免算法”

**拥塞避免算法 – Congestion Avoidance**

如同前边说的，当拥塞窗口大小cwnd大于等于慢启动阈值ssthresh后，就进入拥塞避免算法。算法如下：

1. 收到一个ACK，则cwnd = cwnd + 1 / cwnd
2. 每当过了一个往返延迟时间RTT，cwnd大小加一。

过了慢启动阈值后，拥塞避免算法可以避免窗口增长过快导致窗口拥塞，而是缓慢的增加调整到网络的最佳值。

**拥塞发生状态时的算法**

一般来说，TCP拥塞控制默认认为网络丢包是由于网络拥塞导致的，所以一般的TCP拥塞控制算法以丢包为网络进入拥塞状态的信号。对于丢包有两种判定方式，一种是超时重传RTO[Retransmission Timeout]超时，另一个是收到三个重复确认ACK。

超时重传是TCP协议保证数据可靠性的一个重要机制，其原理是在发送一个数据以后就开启一个计时器，在一定时间内如果没有得到发送数据报的ACK报文，那么就重新发送数据，直到发送成功为止。

但是如果发送端接收到3个以上的重复ACK，TCP就意识到数据发生丢失，需要重传。这个机制不需要等到重传定时器超时，所以叫 做快速重传，而快速重传后没有使用慢启动算法，而是拥塞避免算法，所以这又叫做快速恢复算法。

超时重传RTO[Retransmission Timeout]超时，TCP会重传数据包。TCP认为这种情况比较糟糕，反应也比较强烈：

- 由于发生丢包，将慢启动阈值ssthresh设置为当前cwnd的一半，即ssthresh = cwnd / 2.
- cwnd重置为1
- 进入慢启动过程

所以，TCP Reno算法进行了优化。当收到三个重复确认ACK时，TCP开启快速重传Fast Retransmit算法，而不用等到RTO超时再进行重传：

- cwnd大小缩小为当前的一半
- ssthresh设置为缩小后的cwnd大小
- 然后进入快速恢复算法Fast Recovery。

**快速恢复算法 – Fast Recovery**

TCP Tahoe是早期的算法，所以没有快速恢复算法，而Reno算法有。在进入快速恢复之前，cwnd和ssthresh已经被更改为原有cwnd的一半。快速恢复算法的逻辑如下：

- cwnd = cwnd + 3 *MSS，加3* MSS的原因是因为收到3个重复的ACK。
- 重传DACKs指定的数据包。
- 如果再收到DACKs，那么cwnd大小增加一。
- 如果收到新的ACK，表明重传的包成功了，那么退出快速恢复算法。将cwnd设置为ssthresh，然后进入拥塞避免算法。

#### 5.Docker

1. Docker容器和虚拟机的区别是什么？

答：Docker容器是一种轻量级的虚拟化技术，与传统的虚拟机相比，它可以在更低的开销下提供更高的性能和更快的启动时间。Docker容器共享主机的内核，因此不需要额外的操作系统，可以更有效地利用资源。

2. Docker中的镜像和容器有什么区别？

答：Docker镜像是一个可重复部署的静态文件，它包含了应用程序及其依赖的所有文件和设置。Docker容器是一个运行时实例，可以在Docker镜像的基础上启动，并在其中运行应用程序。

3. 如何使用Docker Compose来管理多个容器？

答：可以使用Docker Compose编写一个YAML文件来定义多个容器，然后使用docker-compose命令来管理这些容器。Docker Compose提供了一种简单的方式来定义、启动和停止多个容器，并管理它们之间的依赖关系。可以使用docker-compose up命令来启动所有容器，使用docker-compose down命令来停止并删除所有容器。

4. 如何使用Docker来实现高可用性？

答：可以使用Docker Swarm来实现高可用性。Docker Swarm是一个原生的Docker集群管理器，可以将多个Docker主机组合在一起，形成一个虚拟的Docker主机，以提供高可用性和负载均衡。Docker Swarm可以自动管理容器的复制和分布，从而提高应用程序的可用性和可靠性。

5. Docker镜像

Docker镜像是一个静态的文件，它包含了一个应用程序及其所有依赖项。镜像是一个只读文件，可以用来创建Docker容器。镜像可以通过Dockerfile定义，Dockerfile是一个包含一系列指令的文本文件，用于自动化构建Docker镜像。

6. Docker容器

Docker容器是Docker镜像的运行实例，它是一个可运行的实例。容器是一个独立的运行环境，它包含了应用程序和其依赖项。容器可以通过镜像创建，镜像提供了容器所需的所有文件和配置信息。容器可以被启动、停止、删除和暂停。

7. Docker引擎

Docker引擎是Docker的核心组件，它提供了Docker的所有基本功能。Docker引擎是一个轻量级的虚拟化技术，它使用Linux内核的一些特性来隔离容器和宿主机之间的资源。Docker引擎包括了一个Docker守护进程、Docker客户端和一个API，它们共同协作来管理容器和镜像。

8. Docker Registry

Docker Registry是一个用于存储和分发Docker镜像的中央仓库。Docker官方提供了Docker Hub，它是一个公共的Docker镜像仓库。用户也可以使用私有的Docker Registry，以便在自己的组织内部存储和分发Docker镜像。

9. Docekr分哪些层

   1. 基础镜像层（Base Image Layer）：基础镜像是Docker镜像的第一层，它包含操作系统的核心部分和一些基本的工具和库。基础镜像通常是一个轻量级的Linux发行版，如Alpine、Ubuntu等。

   2. 应用程序镜像层（Application Image Layer）：应用程序镜像是基于基础镜像构建的，它包含应用程序的代码、依赖项、配置文件等。应用程序镜像可以包含多个层，每个层都是在前一个层的基础上构建的。

   3. 可写层（Writable Layer）：当一个容器启动时，Docker会在应用程序镜像之上添加一个可写层，用于存储容器的修改。这个可写层通常是一个临时文件系统，所有对文件系统的修改都保存在这个层中。这个可写层是容器独有的，不会影响其他容器或基础镜像。

   4. 容器层（Container Layer）：容器层是基于可写层构建的，它包含了容器的状态信息、网络配置、运行时参数等。当容器停止时，容器层会被删除，而可写层则会被保留下来，以便在下一次容器启动时使用。

10. Docker如何实现隔离

    1. 命名空间（Namespaces）：Docker使用命名空间隔离了进程、网络、文件系统等方面的资源，每个Docker容器都拥有自己的命名空间，以便隔离容器内部的应用程序和进程。

    2. 控制组（Control Groups）：Docker使用控制组隔离了CPU、内存、磁盘等资源，每个Docker容器都可以被限制在一定的资源范围内，以避免对其他容器或主机造成影响。

    3. 文件系统隔离（File System Isolation）：Docker使用联合文件系统（UnionFS）技术，将多个文件系统合并到一个文件系统中，并以只读方式挂载基础镜像层，以便每个容器都有自己的可写层。

    4. 容器镜像（Container Images）：Docker使用容器镜像来隔离应用程序和依赖项，每个容器镜像都包含了应用程序所需的所有依赖项和配置信息，以确保容器内部环境的一致性。

11. 基本的Docker使用流程
    一切都从Dockerfile开始。Dockerfile是镜像的源代码。创建Dockerfile后，您可以构建它以创建容器的镜像。镜像只是“源代码”的“编译版本”，即Dockerfile。获得容器的镜像后，应使用注册表重新分发容器。注册表就像一个git存储库 - 你可以推送和拉取镜像。接下来，您可以使用该镜像来运行容器。在许多方面，正在运行的容器与虚拟机非常相似。

#### 6.k8s



#### 7.Go Context

Go语言中的context包提供了一个机制来跟踪请求的上下文，并在需要时取消它们。context.Context类型表示一个请求的上下文，它可以在请求的整个生命周期内传递，并在需要时取消。当一个请求被取消时，所有的子请求也将被取消。

context包包含了创建和使用context的函数。在大多数情况下，context都是用来传递一个请求的截止时间、取消信号、请求范围内的数据等信息。

Go语言中的并发编程十分重要，而context就是在并发编程中用于控制goroutine之间的交互和协作的重要工具。

- 「Deadline」 方法：可以获取设置的截止时间，返回值 deadline 是截止时间，到了这个时间，Context 会自动发起取消请求，返回值 ok 表示是否设置了截止时间。
- 「Done」 方法：返回一个只读的 channel ，类型为 struct{}。如果这个 chan 可以读取，说明已经发出了取消信号，可以做清理操作，然后退出协程，释放资源。
- 「Err」 方法：返回Context 被取消的原因。
- 「Value」 方法：获取 Context 上绑定的值，是一个键值对，通过 key 来获取对应的值。

#### 8.JWT

JWT，全称为JSON Web Token，是一种基于JSON的开放标准（RFC 7519），用于在网络应用之间传递声明信息。JWT通常用于身份验证和授权，因为它允许将声明信息包含在其中，而且该信息经过数字签名，因此是可信的。JWT通常是由三部分组成，分别是头部（header）、负载（payload）和签名（signature）。

头部（header）：头部通常包含两部分信息，分别是令牌的类型和使用的签名算法。

负载（payload）：负载是JWT的主体部分，通常包含一些声明信息。声明信息可以分为三种类型：注册声明、公共声明和私有声明。

签名（signature）：签名是JWT的最后一部分，用于验证消息的完整性。签名通常使用使用密钥和指定的签名算法生成。

JWT使用流程通常包括以下几个步骤：

1. 用户使用用户名和密码进行身份验证，服务器验证通过后，生成一个JWT令牌并返回给客户端。
2. 客户端收到JWT令牌后，将其保存在本地存储（通常是浏览器的本地存储或者移动应用程序的本地存储）中。
3. 客户端在后续请求中，将JWT令牌放在请求的Authorization头部中，以Bearer <token>的形式发送给服务器。
4. 服务器在接收到请求后，会先对JWT令牌进行解码和验证，如果JWT令牌合法并且未过期，则将请求处理并返回结果。
5. 如果JWT令牌无效或者已过期，则服务器会拒绝请求并返回错误信息。

#### 9.go垃圾回收

1. GC 原理

   垃圾回收就是对程序中不再使用的内存资源进行自动回收的操作。

   三色标记法

   - 初始状态下所有对象都是白色的。
   - 从根节点开始遍历所有对象，把遍历到的对象变成灰色对象
   - 遍历灰色对象，将灰色对象引用的对象也变成灰色对象，然后将遍历过的灰色对象变成黑色对象。
   - 循环步骤3，直到灰色对象全部变黑色。
   - 通过写屏障(write-barrier)检测对象有变化，重复以上操作
   - 收集所有白色对象（垃圾）。

   STW（Stop The World）

   - 为了避免在 GC 的过程中，对象之间的引用关系发生新的变更，使得GC的结果发生错误（如GC过程中新增了一个引用，但是由于未扫描到该引用导致将被引用的对象清除了），停止所有正在运行的协程。
   - STW对性能有一些影响，Golang目前已经可以做到1ms以下的STW。

2. GC的屏障介绍

   写屏障(Write Barrier)

   - 为了避免GC的过程中新修改的引用关系到GC的结果发生错误，我们需要进行STW。但是STW会影响程序的性能，所以我们要通过写屏障技术尽可能地缩短STW的时间。

   **写屏障**：并发gc会产生黑色节点引用白色节点情况，导致正常的指针变量错误的被清除；解决方法为写屏障；

   主要包括强三色不变式和弱三色不变式；

   **强三色不变**：黑色节点不能引用白色节点，如果引用白色节点需要将白色节点置灰(插入写屏障)；

   **弱三色不变**：黑节点可以引用白节点，但白节点有其他灰色节点或递归指向存在灰色节点，删除白色节点引用时，需要把白色节点置灰(删除写屏障);

   栈上变量较小，且频繁开辟或删除，不开启写屏障；需要之后一次rescan；

   stw时机：

           插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活；(1.5版本采用)
           删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象；

   **混合写屏障**：1.8版本加入

   原因是stw需要耗时；加入混合写屏障，解决这个问题；

   **流程**：

   1.开始标记时候，栈上可达节点均置黑，之后不进行rescan，不用stw；

   2.gc时产生的在栈上创建的对象，均置黑；

   3.堆空间删除的对象置灰；

   4.堆空间插入的对象置灰；

   **特点**

   - 混合写屏障继承了插入写屏障的优点，起始无需 STW 打快照，直接并发扫描垃圾即可；

   - 混合写屏障继承了删除写屏障的优点，赋值器是黑色赋值器，GC 期间，任何在栈上创建的新对象，均为黑色。扫描过一次就不需要扫描了，这样就消除了插入写屏障时期最后 STW 的重新扫描栈；

   - 混合写屏障扫描精度继承了删除写屏障，比插入写屏障更低，随着带来的是 GC 过程全程无 STW；

   - 混合写屏障扫描栈虽然没有 STW，但是扫描某一个具体的栈的时候，还是要停止这个 goroutine 赋值器的工作的哈（针对一个 goroutine 栈来说，是暂停扫的，要么全灰，要么全黑哈，原子状态切换）。

#### 10.进程线程协程

进程、线程和协程是操作系统中的重要概念，它们都是用于实现程序并发执行的机制，但是它们之间有一些区别。

1. 进程是操作系统资源分配的基本单位，每个进程都有自己的地址空间、内存、文件句柄等，进程间通信需要使用IPC（进程间通信）的方式，如管道、消息队列、共享内存等。进程的创建和销毁需要耗费较多的资源，因此进程切换的代价相对较大。
2. 线程是进程内的一个执行单元，一个进程可以拥有多个线程，线程共享进程的地址空间和资源，因此线程之间的通信可以直接访问共享的内存，也因此线程的创建和销毁的代价比进程要小很多。但是，线程切换仍然需要耗费一定的资源。
3. 协程是一种用户态的轻量级线程，协程是由程序员控制的，其调度和切换由程序员自己决定，因此协程的创建和销毁代价很小，协程之间的切换只需保存少量的寄存器上下文，切换的代价很小。协程通常在单个线程内运行，因此多个协程之间的切换不需要涉及操作系统内核，不会引起内核态和用户态之间的切换，相比于线程和进程，协程的性能更高。

#### 11.三门定理

三门定理，又称为布尔-德摩根定理，是关于命题逻辑中命题的逻辑等价性的定理。它由英国数学家乔治·布尔和美国数学家德摩根分别独立发现，因此也被称为布尔-德摩根定理。

三门定理包括以下三个定理：

1. 非 (A 或 B) 等价于 (非 A) 且 (非 B)。
2. 非 (A 且 B) 等价于 (非 A) 或 (非 B)。
3. A 或 (B 且 C) 等价于 (A 或 B) 且 (A 或 C)。

其中 A、B、C 是任意命题。

这些定理提供了一种将布尔逻辑运算符进行重新组合的方法，以便更容易地推导和证明命题。在计算机科学中，这些定理经常用于逻辑优化和简化布尔表达式。

#### 12.for range

在使用 Go 语言中的 `for range` 时需要注意以下几点：

1. `for range` 遍历的是对象的副本，而非对象本身。如果修改遍历的对象本身，会导致遍历结果不可预期。
2. 如果遍历的对象是一个 channel，当 channel 关闭后，`for range` 循环会自动结束。如果 channel 没有关闭，`for range` 会一直阻塞等待新的数据。
3. 在使用 `for range` 遍历 slice 或数组时，返回的索引和值都是该元素的副本。如果需要修改原来的 slice 或数组中的元素，需要通过索引直接访问，而不能通过遍历返回的值来修改。
4. 在使用 `for range` 遍历 map 时，返回的是键值对的副本，包括键和值。如果需要修改原来的 map 中的键或值，需要通过键直接访问，而不能通过遍历返回的副本来修改。
5. 在使用 `for range` 遍历字符串时，返回的是 Unicode 编码，而不是字符串本身。如果需要获取字符串中的字符，请使用 `[]rune` 或 `[]byte` 进行转换。

#### 13.微服务鉴权

微服务鉴权是指在微服务架构中，对服务之间的通信进行授权认证，确保只有被授权的服务可以相互通信。微服务鉴权是保障微服务安全的一种重要措施。

通常，微服务鉴权采用基于令牌的鉴权方式，即服务之间的通信需要在请求中携带有效的令牌才能通过。常用的令牌鉴权方式包括JWT和OAuth2。

具体实现上，可以在网关层实现微服务鉴权，通过网关拦截请求，并对请求进行身份认证和授权鉴定。网关可以通过在请求头中添加令牌等方式，将认证和授权信息传递给后端微服务，后端微服务根据传递的认证信息，对请求进行鉴权。

此外，还可以在服务之间进行鉴权，通过在服务间添加中间件，对请求进行身份认证和授权鉴定。通过在服务内部对请求进行鉴权，可以进一步提高微服务系统的安全性。

总的来说，微服务鉴权是一项重要的安全措施，可以保障微服务系统的安全性和可靠性。

#### 14.GMP

Go语言中的调度器是一个称为GMP的组件，其中G代表goroutine，M代表OS线程，P代表处理器。GMP调度器是Go语言并发模型的核心组件之一，负责管理goroutine的调度和OS线程的创建和销毁。

GMP调度器使用M:N的线程模型，其中M个goroutine被映射到N个OS线程上执行，这样可以在单个OS线程上执行多个goroutine，从而减少线程切换的开销，提高系统的并发性能。

在GMP调度器中，每个goroutine都会被分配到一个P中执行，每个P绑定到一个M上。当goroutine阻塞时，P会将该goroutine从自己的队列中移除，并将其放入全局队列中，然后从M中解绑P并挂起M。当有新的goroutine需要执行时，GMP调度器会从全局队列中获取goroutine并将其分配到一个P中执行。

GMP调度器使用一些技术来优化goroutine的调度和执行，包括抢占式调度、本地和全局队列、休眠和唤醒、以及工作窃取。这些技术使得GMP调度器能够高效地管理大量的goroutine，实现高并发和高性能。

GMP调度的一些流程：

1. 调度器会根据运行时的参数创建一定数量的P，并将它们与M一一绑定，然后开始执行用户代码。
2. 当用户代码中需要创建Goroutine时，调度器会将其分配给某个P，并加入该P的队列中。
3. 当某个Goroutine被阻塞时，所在的P就会从队列中取出另一个Goroutine来执行，从而保证所有Goroutine都能得到充分的利用。
4. 如果某个P的队列中没有Goroutine可以执行，那么调度器就会将该P与M解绑，并将其放到空闲P列表中等待下一个Goroutine到来。
5. 当用户程序结束时，调度器会将所有的P与M解绑，并关闭所有的M，释放相应的资源。

#### 15.goroutine

在 Go 语言中，`goroutine` 是一种轻量级的线程实现，它可以在单个 OS 线程上并发执行代码。与传统线程相比，`goroutine` 更加高效，它的创建和销毁都比较快，同时在运行时占用的内存也比较少。

`goroutine` 可以通过关键字 `go` 来创建，它会在后台启动一个新的 `goroutine`，并在这个新的 `goroutine` 中运行指定的函数。一个程序可以拥有成千上万个 `goroutine`，它们之间的通信可以通过 Go 语言提供的 Channel 实现。通过GMP进行调度。

#### 16.网页加载过程

网页加载过程可以分为以下几个步骤：

1. DNS解析：浏览器通过域名查找IP地址，将域名解析为对应的IP地址。
2. TCP连接：浏览器与服务器建立TCP连接。
3. 发送HTTP请求：浏览器向服务器发送HTTP请求，请求网页的内容。
4. 服务器处理请求并返回HTTP响应：服务器收到请求后，会根据请求内容做出相应的处理，并返回HTTP响应。
5. 浏览器接收响应：浏览器接收到HTTP响应后，开始解析HTML代码，并根据响应中的其他资源链接（如CSS文件、JavaScript文件、图片等）继续发送HTTP请求。
6. 解析静态文件和前端文件，并渲染到页面。
7. 完成页面加载：当浏览器完成所有步骤后，网页加载完成并可以交互。

#### 17.RPC

RPC（Remote Procedure Call，远程过程调用）是一种计算机通信协议，它允许像调用本地服务一样调用远程服务。RPC通过将调用参数和返回值进行编码和解码，使得远程服务调用过程像本地调用一样简单。

RPC的工作流程如下：

1. 客户端通过调用本地存根发起远程调用请求，本地存根将请求进行序列化，打包成网络消息，发送给远程服务端。
2. 远程服务端收到请求消息后，进行反序列化，得到客户端请求的信息。
3. 远程服务端根据请求的信息，调用本地服务并执行请求的操作。
4. 本地服务执行完成后，将结果序列化后返回给客户端。
5. 客户端收到结果消息后进行反序列化，得到最终结果。

#### 18.chan

在 Go 中，通道（chan）是一种通信机制，用于在 Goroutine 之间传递数据。通道可以被用于实现同步和异步通信，可以防止资源竞争，从而避免了锁的使用。

通道可以通过 make() 函数创建，指定通道中元素的类型和缓冲区的大小。

通道的实现原理是基于 CSP（Communicating Sequential Processes）模型，它是一种并发编程模型，用于描述并发系统中的通信和同步操作。在 CSP 模型中，通道是主要的通信方式，Goroutine 通过通道进行通信和同步。

#### 19.mysql索引（包括创建）

MySQL索引是一种数据结构，它可以提高数据库查询的效率。当我们需要在数据库中查询特定记录时，MySQL索引可以帮助数据库系统更快地定位数据，从而加快查询速度。MySQL支持多种类型的索引，包括B-tree索引、哈希索引、全文索引等。

B-tree索引是MySQL中最常用的索引类型。B-tree索引是一种平衡树，它可以快速定位数据记录。在MySQL中创建B-tree索引非常简单，只需要在需要创建索引的列上使用CREATE INDEX语句即可。

1. 覆盖索引

覆盖索引是指查询语句可以完全使用索引中的数据，而不需要回到原始数据表中查找。这种索引可以加快查询速度，因为不需要从磁盘上读取数据，而是直接从内存中获取数据。覆盖索引只包含查询所需的列和索引列，而不包含其他列，因此可以减小索引的大小，节省存储空间。

2. 聚簇索引

聚簇索引是一种特殊的索引，它可以改善查询效率和插入性能。聚簇索引将数据按照主键的顺序存储在磁盘上，因此相邻的数据行也会存储在相邻的磁盘页上。当查询的数据行在磁盘上是相邻的时候，可以减少磁盘的寻道时间，提高查询效率。此外，聚簇索引还可以减少插入新数据时的磁盘写入次数，提高插入性能。

3. 非聚簇索引

非聚簇索引是一种常见的索引类型，它将索引和实际数据分开存储。非聚簇索引包含索引列和指向实际数据行的指针，因此查询需要先访问索引，然后再根据指针访问实际数据行。非聚簇索引可以提高查询效率，因为它可以加快索引的访问速度，但是它也会增加磁盘的读取次数，因此对于大型数据表来说，可能会影响查询性能。

#### 20.mysql存储引擎

MySQL存储引擎是用于存储和检索数据的底层软件组件。它们负责处理数据的物理存储和访问。MySQL支持多种存储引擎，每种存储引擎有其自身的优点和限制，因此在选择存储引擎时需要根据应用程序的需求进行权衡。

下面是MySQL中常见的几种存储引擎的区别：

1. MyISAM：这是MySQL最古老和最广泛使用的存储引擎之一。它不支持事务处理和外键约束，但是具有快速的读取性能和较小的磁盘空间占用。MyISAM适用于需要频繁读取但不需要更新或插入的应用程序，例如Web应用程序。
2. InnoDB：这是MySQL默认的存储引擎，支持事务处理和外键约束。InnoDB使用行级锁定来实现高并发读写，支持多版本并发控制(MVCC)，适用于高并发的在线事务处理(OLTP)应用程序。
3. Memory：这个存储引擎将数据存储在内存中，因此读写速度非常快。它适用于需要快速读写的临时表或缓存表。
4. NDB：这个存储引擎是MySQL集群中使用的分布式存储引擎。它具有高可用性和可扩展性，并且可以在多个节点上分布数据和负载。它适用于需要高可用性和可扩展性的大型分布式应用程序。

#### 21.I/O多路复用

I/O多路复用是一种同时监听多个文件描述符（sockets、文件、管道等）的机制，当有一个或多个文件描述符有数据到达时，就会触发相应的回调函数进行处理。I/O多路复用通常使用操作系统提供的系统调用实现，比如select、poll、epoll等。

1. select

`select` 函数可以同时监视多个文件描述符，一旦某个文件描述符变为就绪状态，就能够通知应用程序进行相应的操作。使用 `select` 函数时，需要将所有要监听的文件描述符加入一个 `fd_set` 集合中，然后调用 `select` 函数，该函数将阻塞，直到有文件描述符就绪或者达到超时时间。在返回后，可以通过遍历 `fd_set` 集合来找到就绪的文件描述符。

`select` 的缺点是：每次调用 `select` 时都需要把所有的文件描述符从用户态拷贝到内核态，这样会带来一定的开销。此外，`select` 对于每个进程打开的文件描述符数量都有限制，这个限制由 `FD_SETSIZE` 宏指定，默认为 1024。

1. poll

`poll` 与 `select` 类似，也可以同时监听多个文件描述符，它的优点是支持更多的文件描述符，通常没有文件描述符数量限制。另外，`poll` 可以避免 `select` 中出现的 fd_set 数组复制问题，提高了性能。使用 `poll` 时，需要将要监听的文件描述符存入一个 `pollfd` 数组中，然后调用 `poll` 函数，该函数也会阻塞，直到有文件描述符就绪或者达到超时时间。在返回后，可以遍历 `pollfd` 数组来找到就绪的文件描述符。

`poll` 的缺点是：仍然需要将所有的文件描述符从用户态拷贝到内核态，而且每次都需要遍历整个 `pollfd` 数组。

1. epoll

`epoll` 是 Linux 下的 I/O 多路复用机制，它可以支持大量的文件描述符，且避免了 `select` 和 `poll` 中存在的性能问题。

使用 `epoll` 时，需要将要监听的文件描述符添加到内核的事件表中，然后调用 `epoll_wait` 函数，该函数也会阻塞，直到有文件描述符就绪或者达到超时时间。在返回后，可以通过遍历内核事件表找到就绪的文件描述符。

#### 22.线程池

线程池是一种常见的并发编程模型，它可以用来管理一组线程，以处理大量的任务。线程池中通常会维护一个任务队列，当有任务到来时，就从队列中取出一个空闲的线程来处理该任务。这种方式可以避免不停地创建和销毁线程的开销，从而提高程序的性能和稳定性。

线程池通常包括以下几个部分：

1. 线程池管理器：负责创建和销毁线程池，并管理任务队列。
2. 任务队列：用于存储需要执行的任务。
3. 线程池工作线程：执行任务的线程。

线程池的实现方式有多种，其中最常见的是固定大小线程池和可变大小线程池。

- 固定大小线程池：在创建线程池时，就预先创建固定数量的线程，这些线程会一直存在，直到线程池被销毁。该线程池适用于任务数量比较稳定的场景。
- 可变大小线程池：该线程池可以根据任务的数量自动调整线程的数量，当任务数量增加时，就创建新的线程来处理任务，当任务数量减少时，就销毁多余的线程。该线程池适用于任务数量变化比较频繁的场景。

#### 23. redis数据结构

1. 字符串（String）：Redis的最基本数据类型，用于存储字符串或二进制数据。字符串类型支持的操作包括获取和设置值、获取子字符串、对数字进行自增/自减操作等。
2. 列表（List）：按照插入顺序排序的字符串列表，支持从列表的头部或尾部插入、删除元素，以及根据下标获取元素等操作。
3. 集合（Set）：无序字符串集合，支持添加、删除、随机获取元素等操作，还支持集合之间的交、并、差等操作。
4. 有序集合（Sorted Set）：按照分数排序的集合，支持添加、删除、按照分数范围获取元素等操作。有序集合在实际应用中经常用来作为排行榜的数据结构。
5. 哈希表（Hash）：类似于字典，是一个键值对集合，其中键和值都是字符串类型。哈希表支持添加、删除、获取元素等操作，还支持获取所有键、值、键值对等操作。
6. Bitmap：Redis提供了一种名为Bitmap的特殊数据结构，用于表示一个只包含0或1的二进制位数组，支持按位操作和计数操作。Bitmap常用于处理一些布尔型的问题，如用户的在线状态、用户的签到记录等。

#### 24.mysql分库分表

MySQL分库分表是一种常用的数据库拆分技术，可以在数据量增大时提高数据库的性能和可用性。它通过将数据按照一定规则拆分成多个数据库或表，使得单个数据库或表的数据量减小，从而提高数据库的读写性能和可扩展性。

分库分表可以按照以下两个维度进行划分：

- 分库：将数据按照业务模块进行拆分，将不同的业务模块放到不同的数据库中，如用户信息、订单信息等。这样可以使得不同业务之间的数据互不影响，提高了可靠性。

- 分表：将单个表中的数据按照某种规则进行拆分，如按照ID值范围、时间等方式。这样可以减少单个表的数据量，提高查询和更新效率，同时也可以使得单个表更易于维护和备份。

1. 水平触发分片 

​	水平触发分片是指按照某个字段（通常是时间或者数据表中某个列的值）的值将数据分散到不同的数据库或表中。例如，可以将某个数据表中不同时间段的数据分别存储在不同的数据库中，或者将同一表中的数据按照某个主键的值进行分割。

​	水平触发分片的优点是易于水平扩展，每个分片都可以存储在不同的物理服务器上，这样可以提高整个系统的并发能力和稳定性。缺点是需要对数据进行复杂的查询和聚合时，需要对所有分片进行合并，这会增加系统的复杂度和查询成本。

2. 边缘触发分片 

​	边缘触发分片是指根据应用程序需要访问的数据，将相关数据放在同一数据库或表中。例如，可以根据用户的ID将相关的数据放在同一数据表中，或者将同一应用程序的相关数据存储在同一数据库中。

​	边缘触发分片的优点是数据的访问和查询速度较快，可以避免跨分片查询的复杂性和性能问题。缺点是需要预测应用程序需要访问的数据，如果分片不够合理或者数据分布不均匀，可能会导致某些分片过载或者空闲。

#### 25.正向反向代理

正向代理（Forward Proxy）和反向代理（Reverse Proxy）是两种常见的代理模式，它们都是用于隐藏客户端和服务器之间的真实身份和位置。

正向代理： 在正向代理模式下，代理服务器充当客户端的代表，向服务器发出请求，并将响应返回给客户端。因此，客户端只能看到代理服务器的IP地址，而无法直接访问服务器。

正向代理常见应用场景包括：

1. 突破网络限制：可以通过正向代理访问无法直接访问的资源，如公司内部的资源。
2. 匿名访问：可以隐藏客户端的真实IP地址，提高匿名性。
3. 缓存静态资源：可以缓存静态资源，减少服务器负载。

反向代理： 在反向代理模式下，代理服务器充当服务器的代表，接收客户端请求并将请求转发给服务器，并将服务器的响应返回给客户端。因此，客户端只能看到代理服务器的IP地址和端口号，而无法直接访问服务器。

反向代理常见应用场景包括：

1. 负载均衡：可以将请求分发到多个服务器上，以提高系统的可扩展性和可用性。
2. 安全保护：可以过滤恶意请求、防止DDoS攻击等。
3. 缓存动态资源：可以缓存动态资源，提高系统性能。

在实际应用中，常常需要同时使用正向代理和反向代理来构建一个完整的代理体系。例如，客户端使用正向代理访问代理服务器，代理服务器再使用反向代理访问后端服务器，实现客户端与服务器之间的隔离和保护。

#### 26.Kafka

1. 什么是Kafka？

   答：Kafka是一个开源分布式流处理平台，它是由Apache软件基金会开发的。它是一种高性能、可扩展、分布式的消息传递系统，可以处理海量数据和流式数据。

2. Kafka有哪些主要组件？ 

   答：Kafka有四个主要组件：Producer、Consumer、Broker和ZooKeeper。Producer将消息发布到Kafka集群，Consumer从集群中读取消息。Broker是Kafka集群中的服务器，用于存储和分发消息。ZooKeeper是一个分布式协调服务，用于管理和监控Kafka集群。

3. Kafka如何保证消息的可靠传递？ 

   答：Kafka使用复制机制来保证消息的可靠传递。每个分区在集群中有多个副本，其中一个被选为领导者（leader），其余副本为追随者（follower）。生产者将消息发送到领导者，领导者将消息复制到所有追随者。只有当所有副本都已确认接收到消息时，才将消息视为已提交。这种机制可以保证即使领导者宕机，也不会丢失消息。

4. Kafka支持哪些消息传递语义？ 

   答：Kafka支持三种消息传递语义：最多一次（at most once）、最少一次（at least once）和恰好一次（exactly once）。最多一次语义表示可能会出现消息丢失；最少一次语义表示可能会出现消息重复；恰好一次语义表示每个消息都被处理一次且仅一次。

5. Kafka的主要优势是什么？ 


- 高吞吐量：Kafka可以处理非常高的消息吞吐量。
- 可扩展性：Kafka可以轻松地扩展以处理更多的数据。
- 容错性：Kafka使用复制机制保证消息的可靠传递，即使集群中的某些节点宕机也不会丢失数据。
- 实时处理：Kafka可以实时处理数据流，而不需要存储在磁盘中等待处理。
- 生态系统：Kafka有一个丰富的生态系统，包括大量的工具和库，可以轻松地与其他系统进行集成。

6. 什么是Kafka的分区（Partition）？ 

   答：Kafka的分区是一个逻辑概念，将一个主题（Topic）划分为多个部分，每个分区都是一个有序的、不可变的消息序列。每个分区可以在集群不同节点之间复制，实现数据的高可用性和容错性。

7. Kafka的消息是如何被保存的？ 

   答：Kafka的消息被保存在分区中，每个分区都有一个本地磁盘存储消息。分区中的消息按照插入的时间顺序进行排序，并且只能追加新的消息，而不能修改或删除已经存在的消息。

8. Kafka的消费者是如何从分区中读取消息的？ 

   答：消费者从指定的分区中读取消息，读取的位置由消费者维护。消费者可以通过轮询或订阅分区来读取消息，也可以通过消费者组（Consumer Group）的方式进行读取。消费者组可以包含多个消费者，每个消费者负责消费一部分分区中的消息。

9. Kafka如何保证消息的顺序性？ 

   答：Kafka通过分区来保证消息的顺序性，每个分区中的消息是有序的。如果生产者在同一个分区中连续地发送消息，那么这些消息的顺序就会被保留下来。但是在不同分区中发送的消息之间，无法保证顺序性。

#### 27.链表反转 链表倒数第K个数

1. 链表反转

   ```
   func reverseList(head *ListNode) *ListNode {
       var pre *ListNode
       cur := head
       for cur !=nil{
           next := cur.Next
           cur.Next = pre
           pre = cur
           cur = next  
       }
       return pre
   }
   ```

2. 输出链表倒数第K个数

   ```
   func getKthFromEnd(head *ListNode, k int) *ListNode {
       pre,cur := head,head
       for pre !=nil && k>0{
           pre = pre.Next
           k--
       }
       for cur !=nil && pre !=nil{
           cur = cur.Next
           pre = pre.Next
       }
       return cur
   }
   ```

#### 28.最长回文子序列 最长公共子序列 最长回文子串

1. 最长回文子序列

   给你一个字符串 `s` ，找出其中最长的回文子序列，并返回该序列的长度。

   子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

   ```
   func longestPalindromeSubseq(s string) int {
       size := len(s)
       dp := make([][]int,len(s))
       for i:=0;i<len(dp);i++{
           dp[i] = make([]int,len(s))
           dp[i][i]=1
       }
       for i:=size-1;i>=0;i--{
           for j:=i+1;j<size;j++{
               if s[i]==s[j]{
                   dp[i][j] = dp[i+1][j-1]+2
               }else{
                   dp[i][j] = max(dp[i+1][j],dp[i][j-1])
               }
           }
       }
       return dp[0][size-1]
   }
   func max(n1,n2 int)int{
       if n1>n2{
           return n1
       }
       return n2
   }
   ```

2. 最长公共子序列 

   给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

   一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

   - 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

   两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

   ```
   func longestCommonSubsequence(text1 string, text2 string) int {
       t1,t2 := len(text1),len(text2)
       dp := make([][]int,t1+1)
       for i:=0;i<=t1;i++{
           dp[i]=make([]int,t2+1)
       }
       for i:=1;i<=t1;i++{
           for j:=1;j<=t2;j++{
               if text1[i-1]==text2[j-1]{
                   dp[i][j] = dp[i-1][j-1]+1
               }else{
                   dp[i][j] = max(dp[i-1][j],dp[i][j-1])
               }
           }
       }
       return dp[t1][t2]
   }
   func max(n1,n2 int)int{
       if n1>n2{
           return n1
       }
       return n2
   }

3. 最长回文子串

   给你一个字符串 `s`，找到 `s` 中最长的回文子串。

   如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。

   ```
   func longestPalindrome(s string) string { 
   max := 0 // 定义起始字符下标 
   start := 0
   // 循环遍历每一个字符
   for i := 0; i < len(s); i++ {
       // 定义记录回文长度的变量
       len1, len2 := 0, 0
       // 奇数情况
       for j := 0; i-j >= 0 && i+j < len(s) && s[i-j] == s[i+j]; j++ {
           len1 = j * 2 + 1
       }
       // 偶数情况
       for j := 0; i-j >= 0 && i+1+j < len(s) && s[i-j] == s[i+1+j]; j++ {
           len2 = j * 2 + 2
       }
       // 求出最长子串
       if len1 > max {
           max = len1
           start = i - len1/2
       }
       if len2 > max {
           max = len2
           start = i - len2/2 + 1
       }
   }
   // 根据起始字符下标和最长子串长度构造回文子串
   return s[start : start+max]
   }
   ```

#### 29. 两数之和 三数之和 四数之和 回文子串

1. 两数之和 

   ```
   func twoSum(nums []int, target int) []int {
       m := make(map[int]int)
       for index,val := range nums{
           if preindex,ok := m[target-val];ok{
               return []int{index,preindex}
           }else{
               m[val] = index
           }
       }
       return []int{}
   }
   ```

2. 三数之和

   ```
   func threeSum(nums []int) [][]int {
       sort.Ints(nums)
       res := [][]int{}
       for i:=0;i<len(nums);i++{
           if nums[i]>0{
               break
           }
           if i>0&&nums[i]==nums[i-1]{
   			continue
   		}
           right := len(nums)-1
           left := i+1
           for left <right{
               if nums[i] + nums[left]+nums[right]>0{
                   right--     
               }else if nums[i] + nums[left]+nums[right]<0{
                   left++
               }else{
                   n2,n3 := nums[left],nums[right]
                   res = append(res,[]int{nums[i],nums[left],nums[right]})
                   for left<right && nums[right]==n3{
                       right--
                   }
                   for left<right && nums[left]==n2{
                       left++
                   }
               }
           }
       }
       return res
   }
   ```

3. 四数之和

   ```
   func fourSum(nums []int, target int) [][]int {
       if len(nums) <4{
           return nil
       }
       sort.Ints(nums)
       var res [][]int
       for i:=0;i<len(nums)-3;i++{
           n1 :=nums[i]
           if i>0 && nums[i]==nums[i-1]{
               continue
           }
           for j:=i+1;j<len(nums)-2;j++{
               n2 := nums[j]
               if j>i+1 && nums[j]==nums[j-1]{
                   continue
               }
               l,r := j+1,len(nums)-1
               for r>l{
                   n3 ,n4 := nums[l],nums[r]
                   sum := n1+n2+n3+n4
                   if sum >target{
                       r--
                   }else if sum<target{
                       l++
                   }else{
                       res = append(res,[]int{n1,n2,n3,n4})
                       for l<r && n3 == nums[l+1]{
                           l++
                       }
                       for l<r && n4 == nums[r-1]{
                           r--
                       }
                       r--
                       l++
                   }
               }
           }
       }
       return res
   }
   ```

4. 回文子串

   ```
   func countSubstrings(s string) int {
       result :=0
       for i:=0;i<len(s);i++{
           result +=extend(s,i,i,len(s))
           result +=extend(s,i,i+1,len(s))
       }
       return result
   }  
   func extend(s string,i,j,n int)(res int){
       for i>=0 && j<n && s[i]==s[j]{
           i--
           j++
           res++
       }
       return
   }
   ```

   